// Purchases Handlers - Complete implementation for PO, GRN, vendor invoices, and vendor management
package handlers

import (
	"context"
	"net/http"
	"strconv"
	"time"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
)

// PurchaseHandler handles all purchase-related operations
type PurchaseHandler struct {
	db    *GORMDatabase
	cache *CacheService
}

// NewPurchaseHandler creates a new purchase handler
func NewPurchaseHandler(db *GORMDatabase, cache *CacheService) *PurchaseHandler {
	return &PurchaseHandler{db: db, cache: cache}
}

// ==================== PURCHASE ORDER HANDLERS ====================

// GetPurchaseOrders retrieves all purchase orders with filtering and pagination
func (h *PurchaseHandler) GetPurchaseOrders(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	var orders []PurchaseOrder
	var total int64

	query := h.db.DB.WithContext(ctx).
		Preload("Vendor").
		Preload("Items").
		Preload("Items.Product").
		Model(&PurchaseOrder{}).
		Where("is_active = ?", true)

	// Apply filters
	if vendorID := c.Query("vendor_id"); vendorID != "" {
		query = query.Where("vendor_id = ?", vendorID)
	}
	if status := c.Query("status"); status != "" {
		query = query.Where("status = ?", status)
	}
	if startDate := c.Query("start_date"); startDate != "" {
		if date, err := time.Parse("2006-01-02", startDate); err == nil {
			query = query.Where("order_date >= ?", date)
		}
	}
	if endDate := c.Query("end_date"); endDate != "" {
		if date, err := time.Parse("2006-01-02", endDate); err == nil {
			query = query.Where("order_date <= ?", date)
		}
	}
	if search := c.Query("search"); search != "" {
		query = query.Where("po_number ILIKE ? OR vendor_id IN (SELECT id FROM vendors WHERE name ILIKE ? OR phone ILIKE ?)",
			"%"+search+"%", "%"+search+"%", "%"+search+"%")
	}

	// Pagination
	limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))
	offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))

	if err := query.Count(&total).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to count purchase orders"})
		return
	}

	if err := query.Limit(limit).Offset(offset).Order("created_at DESC").Find(&orders).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve purchase orders"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"orders": orders,
		"total":  total,
		"limit":  limit,
		"offset": offset,
	})
}

// GetPurchaseOrder retrieves a specific purchase order
func (h *PurchaseHandler) GetPurchaseOrder(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	id := c.Param("id")
	var order PurchaseOrder

	if err := h.db.DB.WithContext(ctx).
		Preload("Vendor").
		Preload("Items").
		Preload("Items.Product").
		Where("id = ? AND is_active = ?", id, true).
		First(&order).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, gin.H{"error": "Purchase order not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve purchase order"})
		return
	}

	c.JSON(http.StatusOK, order)
}

// CreatePurchaseOrder creates a new purchase order
func (h *PurchaseHandler) CreatePurchaseOrder(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	var order PurchaseOrder
	if err := c.ShouldBindJSON(&order); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Set created by from JWT token
	userID, exists := c.Get("user_id")
	if exists {
		order.CreatedBy = userID.(string)
	}

	// Set default status
	order.Status = "draft"

	// Calculate totals
	for i := range order.Items {
		item := &order.Items[i]
		item.TotalAmount = item.Quantity * item.UnitPrice
		item.DiscountAmount = (item.TotalAmount * item.DiscountPercent) / 100
		item.TaxAmount = ((item.TotalAmount - item.DiscountAmount) * item.TaxPercent) / 100
		item.TotalAmount = item.TotalAmount - item.DiscountAmount + item.TaxAmount
	}

	order.Subtotal = 0
	order.TaxAmount = 0
	order.TotalAmount = 0

	for _, item := range order.Items {
		order.Subtotal += item.Quantity * item.UnitPrice
		order.TaxAmount += item.TaxAmount
		order.TotalAmount += item.TotalAmount
	}

	if err := h.db.DB.WithContext(ctx).Create(&order).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create purchase order"})
		return
	}

	// Clear cache
	h.cache.DeletePattern(ctx, "purchase_orders:*")

	c.JSON(http.StatusCreated, order)
}

// UpdatePurchaseOrder updates an existing purchase order
func (h *PurchaseHandler) UpdatePurchaseOrder(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	id := c.Param("id")
	var order PurchaseOrder

	if err := h.db.DB.WithContext(ctx).Where("id = ? AND is_active = ?", id, true).First(&order).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, gin.H{"error": "Purchase order not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve purchase order"})
		return
	}

	var updateData PurchaseOrder
	if err := c.ShouldBindJSON(&updateData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Update fields
	order.VendorID = updateData.VendorID
	order.PaymentTerms = updateData.PaymentTerms
	order.Notes = updateData.Notes

	// Recalculate totals
	for i := range updateData.Items {
		item := &updateData.Items[i]
		item.TotalAmount = item.Quantity * item.UnitPrice
		item.DiscountAmount = (item.TotalAmount * item.DiscountPercent) / 100
		item.TaxAmount = ((item.TotalAmount - item.DiscountAmount) * item.TaxPercent) / 100
		item.TotalAmount = item.TotalAmount - item.DiscountAmount + item.TaxAmount
	}

	order.Items = updateData.Items

	order.Subtotal = 0
	order.TaxAmount = 0
	order.TotalAmount = 0

	for _, item := range order.Items {
		order.Subtotal += item.Quantity * item.UnitPrice
		order.TaxAmount += item.TaxAmount
		order.TotalAmount += item.TotalAmount
	}

	if err := h.db.DB.WithContext(ctx).Save(&order).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update purchase order"})
		return
	}

	// Clear cache
	h.cache.DeletePattern(ctx, "purchase_orders:*")

	c.JSON(http.StatusOK, order)
}

// DeletePurchaseOrder soft deletes a purchase order
func (h *PurchaseHandler) DeletePurchaseOrder(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	id := c.Param("id")

	if err := h.db.DB.WithContext(ctx).Model(&PurchaseOrder{}).Where("id = ?", id).Update("is_active", false).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete purchase order"})
		return
	}

	// Clear cache
	h.cache.DeletePattern(ctx, "purchase_orders:*")

	c.JSON(http.StatusNoContent, nil)
}

// ApprovePurchaseOrder approves a purchase order for processing
func (h *PurchaseHandler) ApprovePurchaseOrder(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	id := c.Param("id")
	userID, _ := c.Get("user_id")

	updates := map[string]interface{}{
		"status":      "sent",
		"approved_by": userID.(string),
		"approved_at": time.Now(),
		"updated_at":  time.Now(),
	}

	if err := h.db.DB.WithContext(ctx).Model(&PurchaseOrder{}).Where("id = ?", id).Updates(updates).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to approve purchase order"})
		return
	}

	// Clear cache
	h.cache.DeletePattern(ctx, "purchase_orders:*")

	c.JSON(http.StatusOK, gin.H{"message": "Purchase order approved successfully"})
}

// GetOrdersByVendor retrieves purchase orders for a specific vendor
func (h *PurchaseHandler) GetOrdersByVendor(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	vendorID := c.Param("vendor_id")
	var orders []PurchaseOrder

	if err := h.db.DB.WithContext(ctx).
		Preload("Vendor").
		Where("vendor_id = ? AND is_active = ?", vendorID, true).
		Order("created_at DESC").
		Find(&orders).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve vendor orders"})
		return
	}

	c.JSON(http.StatusOK, orders)
}

// ==================== GRN HANDLERS ====================

// GetGRN retrieves all GRN with filtering and pagination
func (h *PurchaseHandler) GetGRN(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	var grns []GRN
	var total int64

	query := h.db.DB.WithContext(ctx).
		Preload("Vendor").
		Preload("Items").
		Preload("Items.Product").
		Model(&GRN{}).
		Where("is_active = ?", true)

	// Apply filters
	if vendorID := c.Query("vendor_id"); vendorID != "" {
		query = query.Where("vendor_id = ?", vendorID)
	}
	if status := c.Query("status"); status != "" {
		query = query.Where("status = ?", status)
	}
	if poID := c.Query("po_id"); poID != "" {
		query = query.Where("purchase_order_id = ?", poID)
	}

	// Pagination
	limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))
	offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))

	if err := query.Count(&total).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to count GRN"})
		return
	}

	if err := query.Limit(limit).Offset(offset).Order("created_at DESC").Find(&grns).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve GRN"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"grns":   grns,
		"total":  total,
		"limit":  limit,
		"offset": offset,
	})
}

// GetGRNByID retrieves a specific GRN
func (h *PurchaseHandler) GetGRNByID(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	id := c.Param("id")
	var grn GRN

	if err := h.db.DB.WithContext(ctx).
		Preload("Vendor").
		Preload("Items").
		Preload("Items.Product").
		Where("id = ? AND is_active = ?", id, true).
		First(&grn).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, gin.H{"error": "GRN not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve GRN"})
		return
	}

	c.JSON(http.StatusOK, grn)
}

// CreateGRN creates a new GRN
func (h *PurchaseHandler) CreateGRN(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	var grn GRN
	if err := c.ShouldBindJSON(&grn); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Set created by from JWT token
	userID, exists := c.Get("user_id")
	if exists {
		grn.CreatedBy = userID.(string)
	}

	// Set default status
	grn.Status = "draft"

	// Calculate totals
	grn.TotalQuantity = 0
	grn.TotalAmount = 0

	for _, item := range grn.Items {
		grn.TotalQuantity += item.AcceptedQuantity
		grn.TotalAmount += item.TotalAmount
	}

	if err := h.db.DB.WithContext(ctx).Create(&grn).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create GRN"})
		return
	}

	// Update purchase order status if linked
	if grn.PurchaseOrderID != nil {
		h.updatePurchaseOrderStatus(ctx, *grn.PurchaseOrderID, "received")
	}

	// Clear cache
	h.cache.DeletePattern(ctx, "grn:*")

	c.JSON(http.StatusCreated, grn)
}

// UpdateGRN updates an existing GRN
func (h *PurchaseHandler) UpdateGRN(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	id := c.Param("id")
	var grn GRN

	if err := h.db.DB.WithContext(ctx).Where("id = ? AND is_active = ?", id, true).First(&grn).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, gin.H{"error": "GRN not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve GRN"})
		return
	}

	var updateData GRN
	if err := c.ShouldBindJSON(&updateData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Update fields
	grn.Notes = updateData.Notes

	// Recalculate totals
	grn.TotalQuantity = 0
	grn.TotalAmount = 0

	for _, item := range updateData.Items {
		grn.TotalQuantity += item.AcceptedQuantity
		grn.TotalAmount += item.TotalAmount
	}

	grn.Items = updateData.Items

	if err := h.db.DB.WithContext(ctx).Save(&grn).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update GRN"})
		return
	}

	// Clear cache
	h.cache.DeletePattern(ctx, "grn:*")

	c.JSON(http.StatusOK, grn)
}

// DeleteGRN soft deletes a GRN
func (h *PurchaseHandler) DeleteGRN(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	id := c.Param("id")

	if err := h.db.DB.WithContext(ctx).Model(&GRN{}).Where("id = ?", id).Update("is_active", false).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete GRN"})
		return
	}

	// Clear cache
	h.cache.DeletePattern(ctx, "grn:*")

	c.JSON(http.StatusNoContent, nil)
}

// GetGRNByPurchaseOrder retrieves GRN for a specific purchase order
func (h *PurchaseHandler) GetGRNByPurchaseOrder(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	poID := c.Param("po_id")
	var grns []GRN

	if err := h.db.DB.WithContext(ctx).
		Where("purchase_order_id = ? AND is_active = ?", poID, true).
		Order("created_at DESC").
		Find(&grns).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve GRN for purchase order"})
		return
	}

	c.JSON(http.StatusOK, grns)
}

// updatePurchaseOrderStatus updates the status of a purchase order
func (h *PurchaseHandler) updatePurchaseOrderStatus(ctx context.Context, poID string, status string) {
	updates := map[string]interface{}{
		"status":     status,
		"updated_at": time.Now(),
	}

	h.db.DB.WithContext(ctx).Model(&PurchaseOrder{}).Where("id = ?", poID).Updates(updates)
}

// ==================== VENDOR INVOICE HANDLERS ====================

// GetVendorInvoices retrieves all vendor invoices
func (h *PurchaseHandler) GetVendorInvoices(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	var invoices []VendorInvoice
	var total int64

	query := h.db.DB.WithContext(ctx).
		Preload("Vendor").
		Model(&VendorInvoice{}).
		Where("is_active = ?", true)

	// Apply filters
	if vendorID := c.Query("vendor_id"); vendorID != "" {
		query = query.Where("vendor_id = ?", vendorID)
	}
	if status := c.Query("status"); status != "" {
		query = query.Where("status = ?", status)
	}

	// Pagination
	limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))
	offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))

	if err := query.Count(&total).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to count vendor invoices"})
		return
	}

	if err := query.Limit(limit).Offset(offset).Order("created_at DESC").Find(&invoices).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve vendor invoices"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"invoices": invoices,
		"total":    total,
		"limit":    limit,
		"offset":   offset,
	})
}

// GetVendorInvoice retrieves a specific vendor invoice
func (h *PurchaseHandler) GetVendorInvoice(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	id := c.Param("id")
	var invoice VendorInvoice

	if err := h.db.DB.WithContext(ctx).
		Preload("Vendor").
		Where("id = ? AND is_active = ?", id, true).
		First(&invoice).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, gin.H{"error": "Vendor invoice not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve vendor invoice"})
		return
	}

	c.JSON(http.StatusOK, invoice)
}

// CreateVendorInvoice creates a new vendor invoice
func (h *PurchaseHandler) CreateVendorInvoice(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	var invoice VendorInvoice
	if err := c.ShouldBindJSON(&invoice); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Set created by from JWT token
	userID, exists := c.Get("user_id")
	if exists {
		invoice.CreatedBy = userID.(string)
	}

	// Set default status
	invoice.Status = "draft"
	invoice.PaymentStatus = "unpaid"

	if err := h.db.DB.WithContext(ctx).Create(&invoice).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create vendor invoice"})
		return
	}

	// Clear cache
	h.cache.DeletePattern(ctx, "vendor_invoices:*")

	c.JSON(http.StatusCreated, invoice)
}

// UpdateVendorInvoice updates an existing vendor invoice
func (h *PurchaseHandler) UpdateVendorInvoice(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	id := c.Param("id")
	var invoice VendorInvoice

	if err := h.db.DB.WithContext(ctx).Where("id = ? AND is_active = ?", id, true).First(&invoice).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, gin.H{"error": "Vendor invoice not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve vendor invoice"})
		return
	}

	var updateData VendorInvoice
	if err := c.ShouldBindJSON(&updateData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Update fields
	invoice.PaymentTerms = updateData.PaymentTerms
	invoice.Notes = updateData.Notes

	if err := h.db.DB.WithContext(ctx).Save(&invoice).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update vendor invoice"})
		return
	}

	// Clear cache
	h.cache.DeletePattern(ctx, "vendor_invoices:*")

	c.JSON(http.StatusOK, invoice)
}

// DeleteVendorInvoice soft deletes a vendor invoice
func (h *PurchaseHandler) DeleteVendorInvoice(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	id := c.Param("id")

	if err := h.db.DB.WithContext(ctx).Model(&VendorInvoice{}).Where("id = ?", id).Update("is_active", false).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete vendor invoice"})
		return
	}

	// Clear cache
	h.cache.DeletePattern(ctx, "vendor_invoices:*")

	c.JSON(http.StatusNoContent, nil)
}

// ApproveVendorInvoice approves a vendor invoice for payment
func (h *PurchaseHandler) ApproveVendorInvoice(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	id := c.Param("id")
	userID, _ := c.Get("user_id")

	updates := map[string]interface{}{
		"status":      "confirmed",
		"approved_by": userID.(string),
		"approved_at": time.Now(),
		"updated_at":  time.Now(),
	}

	if err := h.db.DB.WithContext(ctx).Model(&VendorInvoice{}).Where("id = ?", id).Updates(updates).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to approve vendor invoice"})
		return
	}

	// Clear cache
	h.cache.DeletePattern(ctx, "vendor_invoices:*")

	c.JSON(http.StatusOK, gin.H{"message": "Vendor invoice approved successfully"})
}

// ==================== VENDOR HANDLERS ====================

// GetVendors retrieves all vendors
func (h *PurchaseHandler) GetVendors(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	var vendors []Vendor
	var total int64

	query := h.db.DB.WithContext(ctx).Model(&Vendor{}).Where("is_active = ?", true)

	// Apply filters
	if search := c.Query("search"); search != "" {
		query = query.Where("name ILIKE ? OR phone ILIKE ? OR email ILIKE ?",
			"%"+search+"%", "%"+search+"%", "%"+search+"%")
	}

	// Pagination
	limit, _ := strconv.Atoi(c.DefaultQuery("limit", "50"))
	offset, _ := strconv.Atoi(c.DefaultQuery("offset", "0"))

	if err := query.Count(&total).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to count vendors"})
		return
	}

	if err := query.Limit(limit).Offset(offset).Order("name").Find(&vendors).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve vendors"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"vendors": vendors,
		"total":   total,
		"limit":   limit,
		"offset":  offset,
	})
}

// GetVendor retrieves a specific vendor
func (h *PurchaseHandler) GetVendor(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	id := c.Param("id")
	var vendor Vendor

	if err := h.db.DB.WithContext(ctx).Where("id = ? AND is_active = ?", id, true).First(&vendor).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, gin.H{"error": "Vendor not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve vendor"})
		return
	}

	c.JSON(http.StatusOK, vendor)
}

// CreateVendor creates a new vendor
func (h *PurchaseHandler) CreateVendor(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	var vendor Vendor
	if err := c.ShouldBindJSON(&vendor); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	if err := h.db.DB.WithContext(ctx).Create(&vendor).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create vendor"})
		return
	}

	c.JSON(http.StatusCreated, vendor)
}

// UpdateVendor updates an existing vendor
func (h *PurchaseHandler) UpdateVendor(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	id := c.Param("id")
	var vendor Vendor

	if err := h.db.DB.WithContext(ctx).Where("id = ? AND is_active = ?", id, true).First(&vendor).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, gin.H{"error": "Vendor not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve vendor"})
		return
	}

	var updateData Vendor
	if err := c.ShouldBindJSON(&updateData); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Update fields
	vendor.Name = updateData.Name
	vendor.Phone = updateData.Phone
	vendor.Email = updateData.Email
	vendor.Address = updateData.Address
	vendor.City = updateData.City
	vendor.State = updateData.State
	vendor.Pincode = updateData.Pincode
	vendor.GSTNumber = updateData.GSTNumber
	vendor.PaymentTerms = updateData.PaymentTerms

	if err := h.db.DB.WithContext(ctx).Save(&vendor).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update vendor"})
		return
	}

	c.JSON(http.StatusOK, vendor)
}

// DeleteVendor soft deletes a vendor
func (h *PurchaseHandler) DeleteVendor(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	id := c.Param("id")

	if err := h.db.DB.WithContext(ctx).Model(&Vendor{}).Where("id = ?", id).Update("is_active", false).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete vendor"})
		return
	}

	c.JSON(http.StatusNoContent, nil)
}

// GetVendorPerformance retrieves vendor performance metrics
func (h *PurchaseHandler) GetVendorPerformance(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	// Get vendor performance metrics including:
	// - Total orders, total amount
	// - Average delivery time
	// - On-time delivery percentage
	// - Quality ratings

	var performance []map[string]interface{}

	query := `
		SELECT
			v.id,
			v.name,
			COUNT(po.id) as total_orders,
			COALESCE(SUM(po.total_amount), 0) as total_amount,
			AVG(EXTRACT(EPOCH FROM (po.expected_delivery - po.order_date))/86400) as avg_delivery_days,
			COUNT(CASE WHEN po.status = 'received' THEN 1 END) as on_time_deliveries,
			CASE
				WHEN COUNT(po.id) > 0 THEN
					(COUNT(CASE WHEN po.status = 'received' THEN 1 END)::FLOAT / COUNT(po.id)::FLOAT) * 100
				ELSE 0
			END as on_time_percentage
		FROM vendors v
		LEFT JOIN purchase_orders po ON v.id = po.vendor_id AND po.is_active = true
		WHERE v.is_active = true
		GROUP BY v.id, v.name
		ORDER BY total_amount DESC
	`

	if err := h.db.DB.WithContext(ctx).Raw(query).Scan(&performance).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve vendor performance"})
		return
	}

	c.JSON(http.StatusOK, performance)
}

// GetVendorPriceComparison compares prices across vendors for products
func (h *PurchaseHandler) GetVendorPriceComparison(c *gin.Context) {
	ctx, cancel := context.WithTimeout(c.Request.Context(), 30*time.Second)
	defer cancel()

	productID := c.Query("product_id")
	if productID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "product_id is required"})
		return
	}

	var comparisons []map[string]interface{}

	query := `
		SELECT
			v.id,
			v.name,
			poi.unit_price,
			poi.quantity as min_quantity,
			poi.payment_terms,
			po.created_at as last_order_date,
			COUNT(po.id) as order_frequency
		FROM vendors v
		JOIN purchase_order_items poi ON poi.product_id = ?
		JOIN purchase_orders po ON poi.purchase_order_id = po.id AND po.vendor_id = v.id
		WHERE v.is_active = true AND poi.is_active = true AND po.is_active = true
		GROUP BY v.id, v.name, poi.unit_price, poi.quantity, poi.payment_terms, po.created_at
		ORDER BY poi.unit_price ASC
	`

	if err := h.db.DB.WithContext(ctx).Raw(query, productID).Scan(&comparisons).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve price comparison"})
		return
	}

	c.JSON(http.StatusOK, comparisons)
}
